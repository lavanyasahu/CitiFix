import sqlite3
import uuid
from datetime import datetime
import threading

class Database:
    def __init__(self, db_path='civic_issues.db'):
        self.db_path = db_path
        self.lock = threading.Lock()
        self.init_database()
    
    def get_connection(self):
        conn = sqlite3.connect(self.db_path, check_same_thread=False)
        conn.row_factory = sqlite3.Row
        return conn
    
    def init_database(self):
        with self.lock:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            # Create users table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id TEXT PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    phone TEXT,
                    role TEXT DEFAULT 'citizen',
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Create issues table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS issues (
                    id TEXT PRIMARY KEY,
                    title TEXT NOT NULL,
                    description TEXT NOT NULL,
                    category TEXT NOT NULL,
                    latitude REAL NOT NULL,
                    longitude REAL NOT NULL,
                    image_data TEXT,
                    user_id TEXT NOT NULL,
                    status TEXT DEFAULT 'pending',
                    admin_notes TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')
            
            conn.commit()
            conn.close()
    
    def create_user(self, username, email, password_hash, phone, role='citizen'):
        with self.lock:
            conn = None
            try:
                conn = self.get_connection()
                cursor = conn.cursor()
                
                user_id = str(uuid.uuid4())
                cursor.execute('''
                    INSERT INTO users (id, username, email, password_hash, phone, role)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (user_id, username, email, password_hash, phone, role))
                
                conn.commit()
                conn.close()
                return user_id
            except sqlite3.IntegrityError:
                if conn:
                    conn.close()
                return None
    
    def get_user_by_username(self, username):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM users WHERE username = ?', (username,))
        user = cursor.fetchone()
        
        conn.close()
        return dict(user) if user else None
    
    def get_user_by_email(self, email):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM users WHERE email = ?', (email,))
        user = cursor.fetchone()
        
        conn.close()
        return dict(user) if user else None
    
    def create_issue(self, issue_data):
        with self.lock:
            conn = None
            try:
                conn = self.get_connection()
                cursor = conn.cursor()
                
                issue_id = str(uuid.uuid4())[:8]  # Shorter ID for easier tracking
                
                cursor.execute('''
                    INSERT INTO issues (
                        id, title, description, category, latitude, longitude,
                        image_data, user_id, status
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    issue_id, issue_data['title'], issue_data['description'],
                    issue_data['category'], issue_data['latitude'], issue_data['longitude'],
                    issue_data['image_data'], issue_data['user_id'], issue_data['status']
                ))
                
                conn.commit()
                conn.close()
                return issue_id
            except Exception as e:
                if conn:
                    conn.close()
                return None
    
    def get_issues_by_user(self, user_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM issues WHERE user_id = ?
            ORDER BY created_at DESC
        ''', (user_id,))
        
        issues = cursor.fetchall()
        conn.close()
        
        return [dict(issue) for issue in issues]
    
    def get_all_issues(self):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM issues ORDER BY created_at DESC')
        issues = cursor.fetchall()
        
        conn.close()
        return [dict(issue) for issue in issues]
    
    def get_issue_by_id(self, issue_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM issues WHERE id = ?', (issue_id,))
        issue = cursor.fetchone()
        
        conn.close()
        return dict(issue) if issue else None
    
    def update_issue_status(self, issue_id, status, admin_notes=None):
        with self.lock:
            conn = None
            try:
                conn = self.get_connection()
                cursor = conn.cursor()
                
                cursor.execute('''
                    UPDATE issues 
                    SET status = ?, admin_notes = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (status, admin_notes, issue_id))
                
                conn.commit()
                rowcount = cursor.rowcount
                conn.close()
                return rowcount > 0
            except Exception as e:
                if conn:
                    conn.close()
                return False
    
    def get_issue_statistics(self):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT COUNT(*) as total FROM issues')
        total = cursor.fetchone()['total']
        
        cursor.execute("SELECT COUNT(*) as pending FROM issues WHERE status = 'pending'")
        pending = cursor.fetchone()['pending']
        
        cursor.execute("SELECT COUNT(*) as in_progress FROM issues WHERE status = 'in_progress'")
        in_progress = cursor.fetchone()['in_progress']
        
        cursor.execute("SELECT COUNT(*) as resolved FROM issues WHERE status = 'resolved'")
        resolved = cursor.fetchone()['resolved']
        
        conn.close()
        
        return {
            'total': total,
            'pending': pending,
            'in_progress': in_progress,
            'resolved': resolved
        }
    
    def get_recent_issues(self, limit=10):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM issues 
            ORDER BY created_at DESC 
            LIMIT ?
        ''', (limit,))
        
        issues = cursor.fetchall()
        conn.close()
        
        return [dict(issue) for issue in issues]
    
    def get_issues_by_status(self, status):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM issues WHERE status = ? ORDER BY created_at DESC', (status,))
        issues = cursor.fetchall()
        
        conn.close()
        return [dict(issue) for issue in issues]
    
    def get_issues_by_category(self, category):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM issues WHERE category = ? ORDER BY created_at DESC', (category,))
        issues = cursor.fetchall()
        
        conn.close()
        return [dict(issue) for issue in issues]
    
    def get_all_users(self):
        """Get all users - used to check if any users exist"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM users')
        users = cursor.fetchall()
        
        conn.close()
        return [dict(user) for user in users]
